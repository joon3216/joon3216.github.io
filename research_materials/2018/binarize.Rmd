---
title: "Binarizing data using data.table"
header-includes:
 - \usepackage{cancel}
 - \newcommand{\bX}{\mathbf{X}}
 - \newcommand{\bx}{\mathbf{x}}
 - \newcommand{\bY}{\mathbf{Y}}
author: Junkyu Park
output: 
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    includes:
      in_header: 
        - ../../style/all_ga_script.html
        - ../../style/all_navbar_head.html
        - ../../style/all_orange_jp_02_lvl.html
      before_body:
        - ../../style/all_navbar_body_02_lvl.html
      after_body:
        - ../../style/all_footer_02_lvl.html
    # df_print: paged
    toc: FALSE
    self_contained: FALSE
---

The following packages and datasets are used:

```{r loading, warning = F, message = F}
library(data.table)
# devtools::install_github('joon3216/funpark')
library(funpark)
library(pROC)
as_tibble <- dplyr::as_tibble
data(femsmoke, package = 'faraway')
data(nodal, package = 'SMPracticals')
```

<!--html_preserve-->
<div id="TOC" class="toc" style="padding:2rem 2rem 0 0;">
<ul style="list-style:none;">
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#case-studies">2. Case studies</a><ul>
<li><a href="#case-1-nodal">Case 1: <code>nodal</code></a></li>
<li><a href="#case-2-femsmoke">Case 2: <code>femsmoke</code></a></li>
</ul></li>
<li><a href="#session-info">Session info</a></li>
</ul>
</div>
&nbsp;
<!--/html_preserve-->


# 1. Introduction

In order to fit a model using logistic regression, we require a binary response. However, if we are given categorical features, such as age group, then data can be structured so that responses are not binary, but rather a count of cases for each combination of features. As an example, consider `rich` dataset where:

* `is_rich` is a response variable having 1 if the person is rich and 0 otherwise
* `gender` is a categorical variable with two categories: `M` or `F` 
* `criminal_record` is also a categorical variable: `yes` if the person has one, and `no` otherwise

```{r eg1_1}
set.seed(1024)
is_rich <- rbinom(10, size = 1, prob = .5)
gender <- rbinom(10, size = 1, prob = .5)
criminal_record <- rbinom(10, size = 1, prob = .5)

# Binary response
(rich <- data.table(
    gender = ifelse(gender == 1, 'M', 'F'),
    criminal_record = ifelse(criminal_record == 1, 'yes', 'no'),
    is_rich = is_rich
))
```

This `rich` dataset has a binary response. However, when you are given a dataset for the first time, it may have a following form:

```{r eg1_2}
# Binomial response
(rich_binom <- rich[
    order(gender, criminal_record), 
    .(rich = sum(is_rich), not_rich = sum(!is_rich)), 
    by = "gender,criminal_record"
])
```

or:

```{r want, eval = F, echo = F}
rich_binom %>% gather(key, value, -(gender:criminal_record))
```

```{r eg1_3}
# Count; response variable is now 'count', not 'is_rich'
(rich_pois <- melt(
    rich_binom, 
    id.vars = c('gender', 'criminal_record'),
    variable.name = 'is_rich',
    value.name = 'count'
))
```


Forms of `rich_binom` and `rich_pois` allow us to fit binomial and poisson regression respectively, but not the logistic regression. This document is about transforming the second and third dataset into the first one, i.e. binarizing datasets.

```{r practice, eval = F, echo = F}
# https://stackoverflow.com/questions/42700904/efficient-spread-of-values-in-data-table
(testing <- data.table(
    ID = c(1, 1, 1, 2, 3, 3),
    event = c('A', 'B', 'C', 'A', 'A', 'B'),
    meas1 = 1:6 * 100,
    meas2 = 5:10 * 100,
    meas3 = 9:14 * 100
))
dcast(
    testing, 
    ID ~ event, 
    value.var = paste0("meas", 1:3), 
    fun = mean, 
    na.rm = TRUE
)
```


# 2. Case studies

The first case concern with transformation from a binomial response to a binary response, and the second case is from a count response to a binary response.


## Case 1: `nodal`

`nodal` is the dataset where:

* `m` is just a column of ones
* `r` is an indicator of nodal involvement (`1` for yes, `0` for no)
* `aged`, `stage`, `grade`, `xray`, `acid` are categorical features

See [here](https://rdrr.io/cran/SMPracticals/man/nodal.html) for more information.

```{r eg2_1_1}
setDT(nodal)
as_tibble(nodal)
```

We can transform this into `nodal_binom`, the data that has binomial responses:

```{r eg2_1_2}
nodal_binom <- nodal[
    , 
    .(m = sum(m), r = sum(r)), 
    by = c('aged', 'stage', 'grade', 'xray', 'acid')
][
    , 
    c('yes_node', 'no_node', 'm', 'r') := list(r, m - r, NULL, NULL)
][
    order(-yes_node, -no_node)
][]
as_tibble(nodal_binom)
```

`nodal_binom` has a form of `rich_binom`, where the last two columns are computed from `r`, the binary response in the original `nodal` data. `yes_node` is a count of 1's in `r` in the original dataset, and `no_node` a count of 0's.

The function `binarize` will convert `nodal_binom` back to `nodal`. `dpmf` and `rpmf` (in `funpark` package) are used to create random names for variable and value columns in order to avoid duplicate names:


```{r eg2_1_3, eval = F}
set.seed(1024)
binarize <- function(dat, family, responses = NULL) {
    # dat: a data whose features are categorical
    # family: either 'binomial' or 'poisson'; must be specified
    # responses (must be specified): 
    #     * If family == 'binomial', then it must be a character vector of
    #       length 2 where each element is the name of column that stores 
    #       the counts of positive and negative responses, in this order.
    #     * If family == 'poisson', then it must be a character vector of
    #       length 1; the character is the column name that stores counts.
    
    # Generate random names to avoid the same names as in features
    all_alphabets <- c(
        'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f',
        'G', 'g', 'H', 'h', 'I', 'i', 'J', 'j', 'K', 'k', 'L', 'l',
        'M', 'm', 'N', 'n', 'O', 'o', 'P', 'p', 'Q', 'q', 'R', 'r',
        'S', 's', 'T', 't', 'U', 'u', 'V', 'v', 'W', 'w', 'X', 'x',
        'Y', 'y', 'Z', 'z'
    )
    dalphabet <- function(x){
        unname(dpmf(
            x, 
            rep(1, length(all_alphabets)) / length(all_alphabets),
            all_alphabets
        ))
    }
    variable_name <- paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')
    value_name <- paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')
    separator <- paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')
    
    # Setup
    col_names <- colnames(dat)
    id_vars <- col_names[!(col_names %in% responses)]
    id_vars_plus <- paste0(id_vars, collapse = ' + ')
    if (!('data.table' %in% class(dat))) {setDT(dat)}
    if (family == 'binomial') {
        # Transform into the form that is used in poisson regression
        dat <- melt(
            dat,
            id.vars = id_vars,
            variable.name = variable_name,
            value.name = value_name
        )
    }
    
    dat_before <- eval(parse(text = paste0(
        'dat[', value_name, ' != 0, ',
        '.(united = do.call(paste, c(.SD, sep = \"', separator, '\")), ',
        value_name, '),',
        '.SDcols = ', id_vars[1], ':', variable_name, ']'
    )))
    dat_before[
        ,
        list(
            result = rep(
                as.data.frame(dat_before)[, 'united'],
                as.data.frame(dat_before)[, value_name]
            )
        )
    ] %>% separate(result, c(id_vars, variable_name), sep = separator)
}
```

```{r eg_rich, echo = F, eval = F}
rich_more <- cbind(rich, region = c('u', 's', 'r', 'd', 'u', 's', 'd', 'r', 's', 'u'))
rich_binom_more <- rich_more[
    order(gender, criminal_record), 
    .(rich = sum(is_rich), not_rich = sum(!is_rich)), 
    by = "gender,criminal_record,region"
]
rich_pois_more <- melt(
    rich_binom_more, 
    id.vars = c('gender', 'criminal_record', 'region'), 
    variable.name = 'is_rich', 
    value.name = 'count'
)

rich_wide <- dcast(
    rich_pois, 
    is_rich ~ gender + criminal_record, 
    value.var = 'count'
)
rich_wide_more <- dcast(
    rich_pois_more, 
    is_rich ~ gender + criminal_record + region, 
    value.var = 'count'
)

rich_binary <- rich_wide[
    ,
    list(
        gender = rep(
            rep(c('F', 'M'), 1),
            c(F_no + F_yes, M_no + M_yes)
        ),
        criminal = rep(
            rep(c('no', 'yes'), 2),
            c(F_no, F_yes, M_no, M_yes)
        )
    ),
    is_rich
][]

rich_binary_2 <- rich_wide[ # Not the correct form!
    ,
    list(
        gender = rep(
            c('F', 'M'),
            c(F_no + F_yes, M_no + M_yes)
        ),
        criminal = rep(
            c('no', 'yes'),
            c(F_no + M_no, F_yes + M_yes)
        )
    ),
    is_rich
][]

rich_more_binary <- rich_wide_more[
    ,
    list(
        gender = rep(
            c('F', 'M'),
            c(F_no_d + F_no_r + F_no_u + F_yes_u +F_yes_s, 
              M_no_r + M_no_s + M_yes_d + M_yes_u)
        ),
        criminal = rep(
            c('no', 'yes', 'no', 'yes'), # f and m * no and yes
            c(F_no_d + F_no_r + F_no_u, F_yes_u + F_yes_s,
              M_no_r + M_no_s, M_yes_d + M_yes_u)
        ),
        region = rep(
            c('d', 'r',      'u', 
                        's', 'u',
                   'r', 's',
              'd',           'u'), 
            # f and m * no and yes * four types of region
            c(F_no_d, F_no_r,          F_no_u,
                              F_yes_s, F_yes_u,
                      M_no_r, M_no_s,
              M_yes_d,                 M_yes_u)
        )
    ),
    is_rich
][]

gender_lvl <- c('F', 'M')
criminal_lvl <- c('no', 'yes')
region_lvl <- c('d', 'r', 's', 'u')
lvl_lst <- list(gender_lvl, criminal_lvl, region_lvl)
wide_more_col_names <- colnames(rich_wide_more)[-1]
all_possible_col_names <- 
    as.data.frame(CJ(gender_lvl, criminal_lvl, region_lvl)[
        , 
        .(result = do.call(paste, c(.SD, sep = "_"))), 
        .SDcols = gender_lvl:region_lvl
    ])[, 'result']
to_keep <- which(all_possible_col_names %in% wide_more_col_names)
# or expand.grid instead of CJ, or tidyr::crossing

# Different way
rich_pois_step <- rich_pois[
    count != 0,
    .(united = do.call(paste, c(.SD, sep = 'wwnsvwepfd')), count),
    .SDcols = gender:is_rich
]
rich_binary2 <- rich_pois_step[
    ,
    list(
        result = rep(
            rich_pois_step %>% pull(united), 
            rich_pois_step %>% pull(count)
        )
    )
]
rich_binary2 %>% 
    tidyr::separate(
        result,
        c('gender', 'criminal', 'is_rich'),
        sep = 'wwnsvwepfd'
    )
```


```{r eg_nodal, eval = F, echo = F}
lvls1 <- c('0', '1')
lvls2 <- c('0', '1')
lvls3 <- c('0', '1')
lvls4 <- c('0', '1')
lvls5 <- c('0', '1')
all_poss_lvls <- 
    as.data.frame(
        CJ(lvls1, lvls2, lvls3, lvls4, lvls5)[
            ,
            .(result = do.call(paste, c(.SD, sep = "_"))),
            .SDcols = lvls1:lvls5
        ]
    )[, 'result']

dat_wide_col_names <- colnames(dat_wide)[-1]
to_keep_names <- which(all_poss_lvls %in% dat_wide_col_names)

dat_binary <- dat_wide[
    ,
    list(
        id_vars[1] = rep(
            rep(),
            c()
        ),
        id_vars[2] = rep(
            rep(),
            c()
        ),
        id_vars[3] = rep(
            rep(),
            c()
        ),
        id_vars[4] = rep(
            rep(),
            c()
        ),
        id_vars[5] = rep(
            rep(),
            c()
        ),
    ),
    colnames(dat_wide)[1]
][]
```


## Case 2: `femsmoke`






# Session info

R session info:

```{r session_info}
sessionInfo()
```





