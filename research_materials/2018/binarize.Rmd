---
title: "Binarizing data using data.table"
author: Junkyu Park
output: 
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    includes:
      in_header: 
        - ../../style/all_ga_script.html
        - ../../style/all_navbar_head.html
        - ../../style/all_orange_jp_02_lvl.html
      before_body:
        - ../../style/all_navbar_body_02_lvl.html
      after_body:
        - ../../style/all_footer_02_lvl.html
    # df_print: paged
    toc: FALSE
    self_contained: FALSE
---

The following packages and datasets are used:

```{r loading, warning = F, message = F}
library(data.table)
# devtools::install_github('joon3216/funpark')
library(funpark)
library(pROC)
as_tibble <- dplyr::as_tibble
data(femsmoke, package = 'faraway')
data(nodal, package = 'SMPracticals')
```

<!--html_preserve-->
<div id="TOC" class="toc" style="padding:2rem 2rem 0 0;">
<ul style="list-style:none;">
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#case-studies">2. Case studies</a><ul>
<li><a href="#case-1-nodal">Case 1: <code>nodal</code></a></li>
<li><a href="#case-2-femsmoke">Case 2: <code>femsmoke</code></a></li>
</ul></li>
<li><a href="#session-info">Session info</a></li>
<li><a href="#related-pages">Related pages</a></li>
</ul>
</div>
&nbsp;
<!--/html_preserve-->


# 1. Introduction

In order to fit a model using logistic regression, we require a binary response. However, if we are given categorical features, such as age group, then data can be structured so that responses are not binary, but rather a count of cases for each combination of features. As an example, consider `rich` dataset where:

* `is_rich` is a response variable having 1 if the person is rich and 0 otherwise
* `gender` is a categorical variable with two categories: `M` or `F` 
* `criminal_record` is also a categorical variable: `yes` if the person has one, and `no` otherwise

```{r eg1_1}
set.seed(1024)
is_rich <- rbinom(10, size = 1, prob = .5)
gender <- rbinom(10, size = 1, prob = .5)
criminal_record <- rbinom(10, size = 1, prob = .5)

# Binary response
(rich <- data.table(
    gender = ifelse(gender == 1, 'M', 'F'),
    criminal_record = ifelse(criminal_record == 1, 'yes', 'no'),
    is_rich = is_rich
))
```

This `rich` dataset has a binary response. However, when you are given a dataset for the first time, it may have a following form:

```{r eg1_2}
# Binomial response
(rich_binom <- rich[
    order(gender, criminal_record), 
    .(rich = sum(is_rich), not_rich = sum(!is_rich)), 
    by = "gender,criminal_record"
])
```

or:

```{r want, eval = F, echo = F}
rich_binom %>% gather(key, value, -(gender:criminal_record))
```

```{r eg1_3}
# Count; response variable is now 'count', not 'is_rich'
(rich_pois <- melt(
    rich_binom, 
    id.vars = c('gender', 'criminal_record'),
    variable.name = 'is_rich',
    value.name = 'count'
))
```


Forms of `rich_binom` and `rich_pois` allow us to fit binomial and poisson regression respectively, but not the logistic regression. This document is about transforming the second and third dataset into the first one, i.e. binarizing datasets.

```{r practice, eval = F, echo = F}
# https://stackoverflow.com/questions/42700904/efficient-spread-of-values-in-data-table
(testing <- data.table(
    ID = c(1, 1, 1, 2, 3, 3),
    event = c('A', 'B', 'C', 'A', 'A', 'B'),
    meas1 = 1:6 * 100,
    meas2 = 5:10 * 100,
    meas3 = 9:14 * 100
))
dcast(
    testing, 
    ID ~ event, 
    value.var = paste0("meas", 1:3), 
    fun = mean, 
    na.rm = TRUE
)
```


# 2. Case studies

The first case concern with transformation from a binomial response to a binary response, and the second case is from a count response to a binary response.


## Case 1: `nodal`

`nodal` is the dataset in `SMPracticals` package where:

* `m` is just a column of ones
* `r` is an indicator of nodal involvement (`1` for yes, `0` for no)
* `aged`, `stage`, `grade`, `xray`, `acid` are categorical features

See [here](https://rdrr.io/cran/SMPracticals/man/nodal.html) for more information.

```{r eg2_1_1}
setDT(nodal)
as_tibble(nodal)
```

We can transform this into `nodal_binom`, the data that has binomial responses:

```{r eg2_1_2}
nodal_binom <- nodal[
    , 
    .(m = sum(m), r = sum(r)), 
    by = c('aged', 'stage', 'grade', 'xray', 'acid')
][
    , 
    c('yes_node', 'no_node', 'm', 'r') := list(r, m - r, NULL, NULL)
][
    order(-yes_node, -no_node)
][]
as_tibble(nodal_binom)
```

`nodal_binom` has a form of `rich_binom`, where the last two columns are computed from `r`, the binary response in the original `nodal` data. `yes_node` is a count of 1's in `r` in the original dataset, and `no_node` a count of 0's.

The function `binarize` will convert `nodal_binom` back to `nodal`. `dpmf` and `rpmf` (in `funpark` package) are used to create random names for variable and value columns in order to avoid duplicate names:



```{r eg2_1_3, eval = T}
binarize <- function(dat, family, responses, 
                     value.name = NULL, positive_level = NULL) {
    # dat: a data whose features are categorical
    # family: (must be specified) either 'binomial' or 'poisson'
    # responses: (must be specified) a character vector of:
    #     * length 2 if family == 'binomial'. Each element is the name of 
    #       column that stores the counts of positive and negative responses, 
    #       in this order.
    #     * length 1 if if family == 'poisson'. Each element is the name of 
    #       column that stores counts.
    # value.name: a character; if NULL, then a randomly generated 
    #             character will be used
    # positive_level: (only used when family = 'poisson') a character that
    #                 specifies a positive class
    
    # Generate random names to avoid the same names as in features
    all_alphabets <- c(
        'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f',
        'G', 'g', 'H', 'h', 'I', 'i', 'J', 'j', 'K', 'k', 'L', 'l',
        'M', 'm', 'N', 'n', 'O', 'o', 'P', 'p', 'Q', 'q', 'R', 'r',
        'S', 's', 'T', 't', 'U', 'u', 'V', 'v', 'W', 'w', 'X', 'x',
        'Y', 'y', 'Z', 'z'
    )
    dalphabet <- function(x){
        dpmf(
            x, 
            rep(1, length(all_alphabets)) / length(all_alphabets),
            all_alphabets
        )
    }
    separator <- 
        paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')
    united <- 
        paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')
    miss_val <- is.null(value.name)
    
    # Setup
    col_names <- colnames(dat)
    id_vars <- col_names[!(col_names %in% responses)]
    if (!('data.table' %in% class(dat))) {setDT(dat)}
    if (family == 'binomial') {
        if (miss_val) {
            value_name <- 
                paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')
            message('Randomly generated value name used: ', value_name)
        } else {
            value_name <- value.name
        }
        variable_name <- 
            paste0(rpmf(10, dalphabet, all_alphabets), collapse = '')

        # Transform into the form that is used in poisson regression
        dat <- melt(
            dat,
            id.vars = id_vars,
            variable.name = variable_name,
            value.name = value_name
        )
        id_vars <- c(id_vars, variable_name)
    } else if (family == 'poisson') {
        if (miss_val) {
            value_name <- responses
            message(
                '\"', value_name, 
                '\" in responses reused as the value name'
            )
        } else {
            value_name <- value.name
            setnames(dat, old = responses, new = value_name)
        }
    } else {
        stop('family must be either \"binomial\" or \"poisson\"')
    }
    dat <- eval(parse(text = paste0(
        'dat[', value_name, ' != 0, ',
        '.(', united, ' = do.call(paste, c(.SD, sep = \"', separator, 
        '\")), ', value_name, '),',
        '.SDcols = ', id_vars[1], ':', id_vars[length(id_vars)], ']'
    )))
    dat <- dat[
        ,
        list(
            result = rep(
                as.data.frame(dat)[, united],
                as.data.frame(dat)[, value_name]
            )
        )
    ][
        , # requires data.table ver >= 1.9.6 because of tstrsplit
        c(id_vars) := tstrsplit(result, separator, fixed = T)
    ][
        , 
        c(id_vars), 
        with = F
    ] 
    if (family == 'binomial') {
        eval(parse(text = paste0(
            'dat[, ',
            value_name, ' := ifelse(',
            id_vars[length(id_vars)], ' == \"', responses[1], '\", 1, 0)]',
            '[, c(id_vars[-length(id_vars)], value_name), with = F]'
        )))
    } else {
        eval(parse(text = paste0(
            'dat[, ',
            value_name, ' := ifelse(',
            id_vars[length(id_vars)], ' == \"', positive_level, '\", 1, 0)]',
            '[, c(id_vars[-length(id_vars)], value_name), with = F]'
        )))
    }
}
```

```{r eg_rich, echo = F, eval = F}
rich_more <- cbind(rich, region = c('u', 's', 'r', 'd', 'u', 's', 'd', 'r', 's', 'u'))
rich_binom_more <- rich_more[
    order(gender, criminal_record), 
    .(rich = sum(is_rich), not_rich = sum(!is_rich)), 
    by = "gender,criminal_record,region"
]
rich_pois_more <- melt(
    rich_binom_more, 
    id.vars = c('gender', 'criminal_record', 'region'), 
    variable.name = 'is_rich', 
    value.name = 'count'
)

rich_wide <- dcast(
    rich_pois, 
    is_rich ~ gender + criminal_record, 
    value.var = 'count'
)
rich_wide_more <- dcast(
    rich_pois_more, 
    is_rich ~ gender + criminal_record + region, 
    value.var = 'count'
)

rich_binary <- rich_wide[
    ,
    list(
        gender = rep(
            rep(c('F', 'M'), 1),
            c(F_no + F_yes, M_no + M_yes)
        ),
        criminal = rep(
            rep(c('no', 'yes'), 2),
            c(F_no, F_yes, M_no, M_yes)
        )
    ),
    is_rich
][]

rich_binary_2 <- rich_wide[ # Not the correct form!
    ,
    list(
        gender = rep(
            c('F', 'M'),
            c(F_no + F_yes, M_no + M_yes)
        ),
        criminal = rep(
            c('no', 'yes'),
            c(F_no + M_no, F_yes + M_yes)
        )
    ),
    is_rich
][]

rich_more_binary <- rich_wide_more[
    ,
    list(
        gender = rep(
            c('F', 'M'),
            c(F_no_d + F_no_r + F_no_u + F_yes_u +F_yes_s, 
              M_no_r + M_no_s + M_yes_d + M_yes_u)
        ),
        criminal = rep(
            c('no', 'yes', 'no', 'yes'), # f and m * no and yes
            c(F_no_d + F_no_r + F_no_u, F_yes_u + F_yes_s,
              M_no_r + M_no_s, M_yes_d + M_yes_u)
        ),
        region = rep(
            c('d', 'r',      'u', 
                        's', 'u',
                   'r', 's',
              'd',           'u'), 
            # f and m * no and yes * four types of region
            c(F_no_d, F_no_r,          F_no_u,
                              F_yes_s, F_yes_u,
                      M_no_r, M_no_s,
              M_yes_d,                 M_yes_u)
        )
    ),
    is_rich
][]

gender_lvl <- c('F', 'M')
criminal_lvl <- c('no', 'yes')
region_lvl <- c('d', 'r', 's', 'u')
lvl_lst <- list(gender_lvl, criminal_lvl, region_lvl)
wide_more_col_names <- colnames(rich_wide_more)[-1]
all_possible_col_names <- 
    as.data.frame(CJ(gender_lvl, criminal_lvl, region_lvl)[
        , 
        .(result = do.call(paste, c(.SD, sep = "_"))), 
        .SDcols = gender_lvl:region_lvl
    ])[, 'result']
to_keep <- which(all_possible_col_names %in% wide_more_col_names)
# or expand.grid instead of CJ, or tidyr::crossing

# Different way
rich_pois_step <- rich_pois[
    count != 0,
    .(united = do.call(paste, c(.SD, sep = 'wwnsvwepfd')), count),
    .SDcols = gender:is_rich
]
rich_binary2 <- rich_pois_step[
    ,
    list(
        result = rep(
            rich_pois_step %>% pull(united), 
            rich_pois_step %>% pull(count)
        )
    )
]
rich_binary2 %>% 
    tidyr::separate(
        result,
        c('gender', 'criminal', 'is_rich'),
        sep = 'wwnsvwepfd'
    )
```


Let's see if it works on `rich_binom` data:

```{r eg2_1_4}
rich # original binary data
rich_binom # transformed into binomial response
# binarized
(rich_binary <- binarize(
    dat = rich_binom, 
    family = 'binomial', 
    responses = c('rich', 'not_rich'), 
    value.name = 'is_rich'
))
```

Is `rich` and `rich_binary` equivalent?

```{r eg2_1_5}
rich_binary[, is_rich := as.integer(is_rich)]
setequal(rich[order(-is_rich, gender, criminal_record)], rich_binary)
```

Yes, they are. Likewise, the binarized `nodal_binom` is the same as the original `nodal`:

```{r eg2_1_6}
as_tibble(binarize(
    nodal_binom, 
    'binomial', 
    c('yes_node', 'no_node')
)) # value.name not specified
```



## Case 2: `femsmoke`

```{r eg2_2_1}
binarize(
    rich_pois, 
    family = 'poisson',
    responses = 'count',
    positive_level = 'rich'
)
```

```{r eg2_2_2}
binarize(
    femsmoke,
    'poisson',
    'y',
    value.name = 'count',
    positive_level = 'yes'
)
```


# Session info

R session info:

```{r session_info}
sessionInfo()
```



# Related pages

* [About `data.table::tstrsplit`](https://stackoverflow.com/questions/18154556/split-text-string-in-a-data-table-columns)




